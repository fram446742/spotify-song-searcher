/*--------------------1. Codigo del Usuario---------------------*/

//------> Paquetes e importaciones
package com.ucjc.compiled.generated;

import java_cup.runtime.*;
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import com.ucjc.utils.TError;
import java.io.FileReader;

/*--------------------2. Opciones y declaraciones--------------------*/

parser code {:
    // Import necessary packages and define additional code if needed

    public String resultado="";
    public static LinkedList<TError> TablaES = new LinkedList<TError>();

    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            Parser asin = new Parser(
                    new Lexer( new FileReader(args[0])));
            Object result = asin.parse().value;
            System.out.println("\n*** Resultados finales ***");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    //Metodo al que se llama automaticamente ante algun error sintactico
    public void syntax_error(Symbol s) {
    Object value = s.value;
    String lexema = (value != null) ? value.toString() : "null";
    int fila = s.right;
    int columna = s.left;

    System.out.println("!!!!!!! Error Sintactico Recuperado !!!!!!!");
    System.out.println("\t\tLexema: " + lexema);
    System.out.println("\t\tFila: " + fila);
    System.out.println("\t\tColumna: " + columna);

    TError datos = new TError(lexema, fila, columna, "Error Sintactico", "Caracter no esperado");
    TablaES.add(datos);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
    Object value = s.value;
    String lexema = (value != null) ? value.toString() : "null";
    int fila = s.right;
    int columna = s.left;

    System.out.println("!!!!!!! Error Sintactico, Panic Mode !!!!!!!");
    System.out.println("\t\tLexema: " + lexema);
    System.out.println("\t\tFila: " + fila);
    System.out.println("\t\tColumna: " + columna);

    TError datos = new TError(lexema, fila, columna, "Error Sintactico", "Caracter no esperado");
    TablaES.add(datos);
    }

    public int error_count() {
        return TablaES.size();
    }

    // Define your data structures and methods here
:};



/* Define terminal and non-terminal symbols */
terminal SONG_NAME, ARTIST, ALBUM, RELEASE_DATE, NUMBER, MILLION_STREAMS, NUM, COMMA, STRING, MORE_THAN, LESS_THAN, MORE_THAN_EQUAL, LESS_THAN_EQUAL, EQUALS, SEARCH, WHITE_SPACE;
non terminal Field, Search, SongNameField, ArtistField, AlbumField, ComparisonOperator, ReleaseDateField, NumberField, MillionStreamsField;

/* Grammar */
precedence left EQUALS;
precedence left MORE_THAN, LESS_THAN, MORE_THAN_EQUAL, LESS_THAN_EQUAL;

/* Define the start symbol */
start with Search;

/* Define the grammar rules */
/* Search Statement */
Search ::= Field
         | Field Search
         | Field SEARCH
         ;

/* Fields */
Field ::= NumberField
        | SongNameField
        | ArtistField
        | AlbumField
        | MillionStreamsField
        | ReleaseDateField
        | COMMA
        | STRING
        ;

/* Specific Fields */
NumberField ::= NUMBER:a EQUALS:b NUM:c {: RESULT = String.valueOf(a) + "\u0020" + String.valueOf(b) + "\u0020" + String.valueOf(c); :};

SongNameField ::= SONG_NAME:a EQUALS:b STRING:c {: RESULT = String.valueOf(a) + "\u0020" + String.valueOf(b) + "\u0020" + String.valueOf(c); :};

ArtistField ::= ARTIST:a EQUALS:b STRING:c {: RESULT = String.valueOf(a) + "\u0020" + String.valueOf(b) + "\u0020" + String.valueOf(c); :};

AlbumField ::= ALBUM:a EQUALS:b STRING:c {: RESULT = String.valueOf(a) + "\u0020" + String.valueOf(b) + "\u0020" + String.valueOf(c); :};

MillionStreamsField ::= MILLION_STREAMS:a ComparisonOperator:b NUM:c {: RESULT = String.valueOf(a) + "\u0020" + String.valueOf(b) + "\u0020" + String.valueOf(c); :};

ReleaseDateField ::= RELEASE_DATE:a EQUALS:b STRING:c {: RESULT = String.valueOf(a) + "\u0020" + String.valueOf(b) + "\u0020" + String.valueOf(c); :};


ComparisonOperator ::= MORE_THAN
                     | LESS_THAN
                     | MORE_THAN_EQUAL
                     | LESS_THAN_EQUAL
                     | EQUALS
                     ;


